<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- saved from url=(0065)https://www.greenarraychips.com/home/documents/pub/AP001-MD5.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
 <title>AP001-MD5</title>
<link rel="stylesheet" type="text/css" href="./AP001-MD5_files/gadoc.css">
</head>
<body>
<h1>Application Note 001: Implementing MD5 On a GreenArraysâ„¢ Chip</h1>
MD5 is a well known cryptographic algorithm, calculating a one way hash function of 128 bits on an arbitrarily long sequence of octets; it is a standard component of many cryptosystems including IPSec and Public Key Infrastructures. There are many possible ways to implement such an algorithm on GreenArrays chips; the implementation described in the first part of this document is the first we have produced (written by staff member Charley Shattuck) and is written as machine code for a cluster of F18 computers. This method generally leads to maximum speed, no dependency on external memory or high level programming such as eForth, and may be adapted for commitment to ROM if desired.
<p>A definitive specification for the MD5 algorithm is published by the Internet Engineering Task Force as <a href="http://www.ietf.org/rfc/rfc1321.txt"> RFC 1321</a> and a discussion of performance is available in <a href="http://www.ietf.org/rfc/rfc1810.txt"> RFC 1810</a> as well as tables in books such as <i>Applied Cryptography</i> by Bruce Schneier. Incidentally, our own reference FORTH implementation running on a PC with 2.9 GHz modern Intel processor hashes 1,000,000 bytes in 3.782 milliseconds for a hash speed of 2.12 gigabits per second.
</p><p>MD5 presents a few problems for programming a Green Arrays device. For one thing it depends on modulo 32 bit addition and rotation. Green Arrays chips deal in 18 bit quantities. For another, md5 is complicated enough that neither the code nor the set of constants required to implement the algorithm will fit into one or even two or three nodes of a Green Arrays computer. Let's see how to deal with that.
</p><h2>Data Sources</h2>
During each step of the MD5 algorithm there are three main sources of data and several numerical sequences for accessing this data.
<p>The first data source is the current state of the message digest, represented as ABCD. It contains 4 32 bit numbers. Temporary storage for A, B, C, and D is required as well. Let's call that AA, BB, CC, and DD, each a 32 bit number. ABCD is accessed in rotating fashion as ABCD, DABC, CDAB, BCDA, and so on as the algorithm proceeds.
</p><p>The second data source is the message buffer, represented by X(k). The message is divided into blocks of 64 bytes or 16 32 bit words, indexed by the sequence represented by k. The message buffer is accessed in an order that is not linear, but which can be calculated in less space than it can be listed in.
</p><p>The third data source is 64 32 bit word constants in a table represented by T(i). These constants are accessed in a linear fashion via the index i.
</p><p>Finally there is a sequence of 64 numbers representing a rotation amount, called s. This sequence can also be calculated in less space than would be required to list it.
</p><p>There are four bitwise functions applied to the ABCD data. They are called f', g', h', and i' where:
</p><p>f'(X, Y, Z) = (X and Y) ior (not(X) and Z)
</p><p>g'(X, Y, Z) = (X and Z) ior (Y and not(Z))
</p><p>h'(X, Y, Z) = (X xor Y) xor Z
</p><p>i'(X, Y, Z) = Y xor (X ior not(Z))
</p><p>Note that ior (inclusive or) and xor (exclusive or) are spelled out in order to be perfectly clear.
</p><p>Let abcd represent the current rotation of ABCD, DABC, CDAB, or BCDA. Let "function" stand for one of the four functions listed above. Using the other symbols also introduced above this is how the 64 operations for each message buffer will look:
</p><p>a := b + (rotate ( s, (a + function(bcd) + X(k) + T(i))))
</p><h2>Green Arrays Architecture</h2>
A couple of things about the Green Arrays architecture dominate this implementation of MD5. One is the fact that MD5 is a 32 bit algorithm and GA architecture is 18 bits. The other is that each node of a Green Arrays chip is limited to 64 18 bit words of memory for both program and data.
<p>To address the first item we will perform all the 32 bit arithmetic and logic in parallel, 16 bits per partner node. For addition, carries can be accumulated in the upper two bits of the low word and communicated to the node handling the high word in time to avoid overflow. The second item is addressed by distributing program code and data amoung several nodes which communicate with each other.
</p><p>Note that the four functions specified above are bitwise functions. There is no carry to ripple and no bit rotations occur. This means that two separate nodes can independently perform the high 16 bit and low 16 bit operations without interacting. Nice.
</p><h3>32 Bit Addition and Rotation</h3>
We've split the 32 bit numbers into 16 bits high and 16 bits low, handled by separate but adjacent nodes. The low node can add and maintain the carries for up to three additions before having to pass its two bits of carry up to the high word to be added in.
<p>32 bit rotation can be implemented using the Green Arrays +* instruction. For example, an 18 bit rotation could be performed by putting zeros into S and A and executing +* repeatedly. The 0 in S would be added to T without changing anything and bit(s) would shift from T into A. At the end you could fetch A and or it with T to construct the rotated value.
</p><p>Rotating a 32 bit number is just a bit more complicated. Both the high and low words would be shifted from T into A, but this time the nodes would swap their T values before oring with A. Also the A values would be shifted right two more times via 2/ and anded with ffff before being ored with T.
</p><h3>A Lookup Table with 64 32 Bit Words</h3>
Now we've already split the high and low 16 bit word operations into separate rows of nodes. We therefore need two tables of 64 16 bit words each. We can do that using two nodes <i><b>filled with all data, no code,</b></i> which jump to neighbor ports to receive the code that looks up data. Once each data node has its A register initialized to zero, The data can be looked up with the simple line <code>@+ !p ..</code> executed in its port. The <code>..</code> fills the rest of the current instruction word with nops so that the next opcode will go into slot 0 of the next word.
<h3>Other Code and Data</h3>
The other data buffers, ABCD and the message buffer, are smaller and can be in nodes that also contain code. One pair of nodes is pretty much dedicated to calculating the message buffer index, reading a word each from their buffers, and passing those words down the line to nodes that apply the MD5 algorithm. Since the rotation amount is the same for high word and low word, a single node can calculate this amount and pass it to both the high row and the low row. Similarly a single node buffers ABCD when a particular message block begins and adds that back in to the message digest at the end of that block's processing. One pair of nodes is pretty well occupied with the four bitwise functions but has room to also do a bit of addition before passing the sum off to another pair that handles resolving the carry, fetching and adding the constants from the lookup tables, and performing the 32 bit rotations.
<h2>Data flow block diagram</h2>
In planning a multi-node application for GreenArrays chips, we think in terms of a <i>data flow diagram.</i> The following Figure diagrams this implementation of MD5:
<blockquote><table>
<tbody><tr>
 <td valign="top">
 </td>
</tr>
</tbody></table></blockquote>
<h2>Allocation of Code and Data for MD5</h2>
Let's describe some of the thinking that led up to this layout. After reading and understanding the md5 specification it was obvious that some sort of extended precision arithmetic and logic was needed. MD5 is a 32 bit algorithm and Green Arrays architecture is 18 bits. The first thought was to define 36 bit operators for addition and each of the four bit-oriented functions needed, as well as 32 bit rotation. Each of these was actually coded in order to see how much memory they would consume. After coding the four functions there wasn't room for much else. Each function implied having three double precision items on the stack as inputs. This occupies six stack locations leaving only four more to work with. Stack overflow was a serious possibility. In addition, watching the numbers in the simulator was difficult since they didn't line up in nibbles as 32 bit hex numbers would.
<h3>32 Bit Operations in 16 Bit Halves</h3>
<p>This problem of visibility while debugging is what inspired the idea of splitting 32 bit operations into two 16 bit operations in partner nodes. Suddenly the bit-wise functions only required three stack locations per node instead of six. The lookup tables could be split into a high 16 bit word and a low 16 bit word. Numbers being passed from node to node could easily be recognized as high or low 16 bit halves. In addition this introduced some parallel processing to an otherwise very sequential set of operations.
</p><p>When it comes to addition or rotation you might think that propagating the carry across nodes would waste some time and it does, but not as much as you might expect. The low partner node can accumulate carries from up to three additions before propagating it to the high partner in a single addition. 32 bit rotation can be done using the +* instruction to shift bits from T into A then sharing and oring those bits across partner nodes to achieve a 32 bit rotation with the minimum of inter-node communication.
</p><h3>Layout</h3>
<p>The layout of the md5 block diagram is determined to some extent by the need to have partner nodes in communication with each other for carry and rotations. The obvious layout is two rows of nodes one above the other. The block diagram shows high 16 bit nodes in the 200 row and low nodes in the 100 row.
</p><p>First the 64 word lookup tables were placed on the east end of the layout in nodes 207 and 107. After coding the four bit-wise functions in nodes 205 and 105 it was seen that there was still room to put the MD (Message Digest) buffer in the same node simplifying calculations. There wasn't going to be room to code the rotations in the same node, so that was put along with carry resolution and lookup code for the constant tables in 206 and 106 between the functions and the constant tables. This leaves 204 and 104 to the west of the MD buffer for the message buffer. The message buffer contains 16 32 bit words for a total of 64 bytes. The high 16 bit words of the message buffer are in the high row and the low 16 bit words are of course in the low row. There is room in these nodes to calculate the index into the message buffer. Unfortunately there is not room in any of the aforementioned nodes to calculate the rotation amount, so another pair of nodes is tacked on to the west. Since both rows get the same rotation amount, it is only needs to be calculated in the high row and sent down to the low row. The low member of this pair is free for other code and in fact has code to save the old MD and add it to the new after a message block is hashed.
</p><p>Five pairs of nodes have been mentioned so far. These nodes are active in calculating the md5 hash once the MD and message buffers have been filled. One of the western most of these nodes, 103, actually just passes the rotation amount calculated by its partner 203 during the hashing phase. Once the md5 algorithm has been applied to the whole message buffer though, this is the node that receives the new message digest and adds it to the old message digest saved there. Before starting work on a new message block this node will send the current MD values over to the pair that contain the MD buffer and functions.
</p><p>Nodes 206 and 106 need to be adjacent in order for carry to propagate in addition and for rotation, but 207 and 107 only need to communicate with their neighbors 206 and 106 respectively. They could be moved up to 306 and down to 006. 205 and 105 don't need to talk to each other so they could move up to 306 and down to 006 instead of the constant tables. Likewise 204 and 104 don't need to talk to each other, so they could be up in the 300 row and down in the 000 row too. 203 and 103 do need to talk to each other, so they really need to be adjacent as do 202 and 102.
</p><h3>Beginning and Ending the Application</h3>
<p>Another pair of nodes, 202 and 102, is added to the west in order to receive each octet of the message block, assemble them into 16 bit words and distribute those to the high and low buffer nodes. One last node, 002, is added below the low row on the far west side. It receives and passes on message octets, pads the message buffer at the end and gets the other nodes to start their processing. Each node except this one begins by jumping to a neighbor, waiting to be told what to do. This node starts a chain reaction by telling its neighbor to start, that neighbor tells two others to start, each of those tells a neighbor to start until the application is up and running. When the hash is finished each node has returned to its neighbor waiting for instructions except this one which jumps to WARM. This way all the nodes used in the application can be reclaimed to do something else without having to reset the chip. The final addition is node 002. This node accepts octets from the outside and passes them on to node 202, accumulating a bitcount, until a marker is received indicating end of message. At that point node 002 will pad the last message block and insert the bit count before passing the final octets on to node 102.
</p><h2>Discussion of the details</h2>
It's time to talk about the code.
<p></p><table border="4" frame="border" rules="none"><tbody><tr>
<td><br><code>md5</code><code><br><br> </code><code> lod rot msg md5 con dat</code><code><br> </code><code> 202 203 204 205 206 207</code><code><br><br> </code><code> lod sum low md5 con dat</code><code><br> </code><code> 102 103 104 105 106 107</code><code><br><br> </code><code> oct tst</code><code><br> </code><code> 002 003</code><code><br><br></code><code>tst</code><code> sends a test stream to 002</code><code><br></code><code>oct</code><code> receives octets and pads buffer</code><code><br></code><code>lod</code><code> loads msg buffer</code><code><br></code><code>rot</code><code> generates rotation amount</code><code><br></code><code>sum</code><code> adds new md to old</code><code><br></code><code>msg</code><code> message buffer</code><code><br></code><code>md5</code><code> md5 buffer and functions</code><code><br></code><code>con</code><code> constant generator and rotator</code><code><br></code><code>dat</code><code> constant data table</code><code><br><br></code><code>the</code><code> 200</code><code> line works on the high words</code><code><br></code><code>the</code><code> 100</code><code> line works on the low words</code><code><br></code><code>they communicate to resolve carry for</code><code><br></code><code>addition and rotation <br></code><br></td>
<td> </td>
<td>840 list
<br><code>md5 loader</code><code><br></code><code>207</code><code> node</code><code> data high</code><code> 842</code><code> load</code><code> 040</code><code><br></code><code>107</code><code> node</code><code> low</code><code> 844</code><code> load</code><code> 040</code><code><br></code><code>const and adder and rotator</code><code><br></code><code>206</code><code> node</code><code> high</code><code> 846</code><code> load</code><code> 850</code><code> load</code><code> 027</code><code><br></code><code>106</code><code> node</code><code> low</code><code> 848</code><code> load</code><code> 850</code><code> load</code><code> 031</code><code><br></code><code>md5</code><code><br></code><code>205</code><code> node</code><code> high</code><code> 852</code><code> load</code><code> 040</code><code><br></code><code>105</code><code> node</code><code> low</code><code> 852</code><code> load</code><code> 040</code><code><br></code><code>msg</code><code><br></code><code>204</code><code> node</code><code> high</code><code> 0</code><code> org</code><code> 854</code><code> load</code><code> 039</code><code><br></code><code>104</code><code> node</code><code> low</code><code> 0</code><code> org</code><code> 854</code><code> load</code><code> 039</code><code><br></code><code>rots</code><code><br></code><code>203</code><code> node</code><code> high</code><code> 856</code><code> load</code><code> 03B</code><code><br></code><code>103</code><code> node</code><code> low</code><code> 858</code><code> load</code><code> 02F</code><code><br></code><code>message loader</code><code><br></code><code>202</code><code> node</code><code> high</code><code> 860</code><code> load</code><code> 01A</code><code><br></code><code>102</code><code> node</code><code> low</code><code> 862</code><code> load</code><code> 027</code><code><br></code><code>octet feeder</code><code><br></code><code>2</code><code> node</code><code> 864</code><code> load</code><code> 039</code><code><br></code><code>3</code><code> node</code><code> 866</code><code> load</code><code> 02C <br></code><br></td>
</tr></tbody></table>
Starting with the main load block note that the shadow screen on the left has a very simple block diagram with hints as to the functions and placement of each node in the application. The load block on the right follows a pattern of declaring the node being programmed and then loading the source block(s) for that node. The first two lines of yellow words load nodes 207 and 107 with their 64 words of lookup table. Yellow words are executed rather than compiled. Comments show up as a dark shade of gray in html, rather than the white you see in arrayforth. That's because we're using a white background for html rather than the black of arrayforth. Gray words show as light gray italic here. They're used to learn the address at that point in your compiled code.
<p>
</p><table border="4" frame="border" rules="none">
<tbody><tr>
<td><br><code>207</code><code> high data</code><code><br><br></code><code>high</code><code> 16</code><code> bit word of</code><code> 32</code><code> bit lookup table <br></code><br></td>
<td> </td>
<td>842 list
<br><code>207</code><code> high data</code><code> 0</code><code> org</code><code><br></code><code>D76A</code><code> ,</code><code> E8C7</code><code> ,</code><code> 2420</code><code> ,</code><code> C1BD</code><code> ,</code><code><br></code><code>F57C</code><code> ,</code><code> 4787</code><code> ,</code><code> A830</code><code> ,</code><code> FD46</code><code> ,</code><code><br></code><code>6980</code><code> ,</code><code> 8B44</code><code> ,</code><code> FFFF</code><code> ,</code><code> 895C</code><code> ,</code><code><br></code><code>6B90</code><code> ,</code><code> FD98</code><code> ,</code><code> A679</code><code> ,</code><code> 49B4</code><code> ,</code><code><br><br></code><code>F61E</code><code> ,</code><code> C040</code><code> ,</code><code> 265E</code><code> ,</code><code> E9B6</code><code> ,</code><code><br></code><code>D62F</code><code> ,</code><code> 244</code><code> ,</code><code> D8A1</code><code> ,</code><code> E7D3</code><code> ,</code><code><br></code><code>21E1</code><code> ,</code><code> C337</code><code> ,</code><code> F4D5</code><code> ,</code><code> 455A</code><code> ,</code><code><br></code><code>A9E3</code><code> ,</code><code> FCEF</code><code> ,</code><code> 676F</code><code> ,</code><code> 8D2A</code><code> ,</code><code><br><br></code><code>FFFA</code><code> ,</code><code> 8771</code><code> ,</code><code> 6D9D</code><code> ,</code><code> FDE5</code><code> ,</code><code><br></code><code>A4BE</code><code> ,</code><code> 4BDE</code><code> ,</code><code> F6BB</code><code> ,</code><code> BEBF</code><code> ,</code><code><br></code><code>289B</code><code> ,</code><code> EAA1</code><code> ,</code><code> D4EF</code><code> ,</code><code> 488</code><code> ,</code><code><br></code><code>D9D4</code><code> ,</code><code> E6DB</code><code> ,</code><code> 1FA2</code><code> ,</code><code> C4AC</code><code> ,</code><code><br><br></code><code>F429</code><code> ,</code><code> 432A</code><code> ,</code><code> AB94</code><code> ,</code><code> FC93</code><code> ,</code><code><br></code><code>655B</code><code> ,</code><code> 8F0C</code><code> ,</code><code> FFEF</code><code> ,</code><code> 8584</code><code> ,</code><code><br></code><code>6FA8</code><code> ,</code><code> FE2C</code><code> ,</code><code> A301</code><code> ,</code><code> 4E08</code><code> ,</code><code><br></code><code>F753</code><code> ,</code><code> BD3A</code><code> ,</code><code> 2AD7</code><code> ,</code><code> EB86</code><code> ,</code><code><br><br></code><code> <br></code><br></td>
</tr>
</tbody></table>
Here you see the high 16 bits of lookup table data compiled into node 207. Note that the numbers are dark yellow and italic, in other words hexadecimal. You'll find these numbers in <a href="http://www.ietf.org/rfc/rfc1321.txt"> RFC 1321</a> starting on page 12.
<p>
</p><table border="4" frame="border" rules="none">
<tbody><tr>
<td><br><code>107</code><code> low data</code><code><br><br></code><code>low</code><code> 16</code><code> bit word of</code><code> 32</code><code> bit lookup table <br></code><br></td>
<td> </td>
<td>844 list
<br><code>107</code><code> low data</code><code> 0</code><code> org</code><code><br></code><code>A478</code><code> ,</code><code> B756</code><code> ,</code><code> 70DB</code><code> ,</code><code> CEEE</code><code> ,</code><code><br></code><code>FAF</code><code> ,</code><code> C62A</code><code> ,</code><code> 4613</code><code> ,</code><code> 9501</code><code> ,</code><code><br></code><code>98D8</code><code> ,</code><code> F7AF</code><code> ,</code><code> 5BB1</code><code> ,</code><code> D7BE</code><code> ,</code><code><br></code><code>1122</code><code> ,</code><code> 7193</code><code> ,</code><code> 438E</code><code> ,</code><code> 821</code><code> ,</code><code><br><br></code><code>2562</code><code> ,</code><code> B340</code><code> ,</code><code> 5A51</code><code> ,</code><code> C7AA</code><code> ,</code><code><br></code><code>105D</code><code> ,</code><code> 1453</code><code> ,</code><code> E681</code><code> ,</code><code> FBC8</code><code> ,</code><code><br></code><code>CDE6</code><code> ,</code><code> 7D6</code><code> ,</code><code> D87</code><code> ,</code><code> 14ED</code><code> ,</code><code><br></code><code>E905</code><code> ,</code><code> A3F8</code><code> ,</code><code> 2D9</code><code> ,</code><code> 4C8A</code><code> ,</code><code><br><br></code><code>3942</code><code> ,</code><code> F681</code><code> ,</code><code> 6122</code><code> ,</code><code> 380C</code><code> ,</code><code><br></code><code>EA44</code><code> ,</code><code> CFA9</code><code> ,</code><code> 4B60</code><code> ,</code><code> BC70</code><code> ,</code><code><br></code><code>7EC6</code><code> ,</code><code> 27FA</code><code> ,</code><code> 3085</code><code> ,</code><code> 1D05</code><code> ,</code><code><br></code><code>D039</code><code> ,</code><code> 99E5</code><code> ,</code><code> 7CF8</code><code> ,</code><code> 5665</code><code> ,</code><code><br><br></code><code>2244</code><code> ,</code><code> FF97</code><code> ,</code><code> 23A7</code><code> ,</code><code> A039</code><code> ,</code><code><br></code><code>59C3</code><code> ,</code><code> CC92</code><code> ,</code><code> F47D</code><code> ,</code><code> 5DD1</code><code> ,</code><code><br></code><code>7E4F</code><code> ,</code><code> E6E0</code><code> ,</code><code> 4314</code><code> ,</code><code> 11A1</code><code> ,</code><code><br></code><code>7E82</code><code> ,</code><code> F235</code><code> ,</code><code> D2BB</code><code> ,</code><code> D391</code><code> ,</code><code><br><br></code><code> <br></code><br></td>
</tr>
</tbody></table>
And here are the low 16 bit words of each constant, compiled into node 107. Both nodes 107 and 207 jump to their right ports to await instructions from their neighbors.
<p>
</p><table border="4" frame="border" rules="none">
<tbody><tr>
<td><br><code>206 106</code><code> constant generator rotator adder</code><code><br><br></code><code>both partner nodes start at the same address</code><code><br></code><code>to make it easier to get this node started</code><code><br></code><code>from outside <br></code><br></td>
<td> </td>
<td>850 list
<br><code>206 106</code><code> constant generator rotator adder</code><code><br></code><code>here</code><code> 0</code><code> org</code><code><br>get</code><code> 000</code><code> -n</code><code> right b! @p ..</code><code> /</code><code> @+ !p ..</code><code> /</code><code> !b @b ;</code><code><br>go</code><code> 004</code><code> left a! right b!</code><code><br> </code><code> @p !b ..</code><code> /</code><code> dup or a! ..</code><code> /</code><code><br> </code><code> 63</code><code> for @ @ @ . + get +c</code><code><br> </code><code> a push @ rotate +c pop a! ! next ;</code><code><br></code><code>014</code><code> org</code><code> 031</code><code> <br></code><br></td>
</tr>
</tbody></table>
Here is some compiled code, rather than just data. Since this is appnote number one, we'll go into more detail about the source code than will probably be the case in later appnotes. We'll try to point out any arrayforth idioms as well as the meanings of the different colors. Remember that red words are names, green words are compiled, yellow words are executed. Block 850 is common to and compiled by both nodes 206 and 106.
<p><code>get</code> is the same in each node. It grabs the next constant from the neighbor to the right. And each node has the same source for <code>go</code>, though as you'll see in the next two blocks, they call different versions of <code>rotate</code> and <code>+c</code>.
</p><p><code>get</code> writes the instruction word <code>@+ !p ..</code> to the right port. The right neighbor is waiting on that port for this instruction, having had its <code>a</code> register initialized to zero. The result is that a value is retrieved from the table and the pointer is incremented for next time. The idiom in arrayforth is to point the a or b register to a neighbor's port and then fetch a word of instruction and store that word to the port. The code for <code>get</code> begins by storing the address of the right port into the b register. This is followed by <code>@p ..</code>. <code>@p</code> fetches the following word in memory onto the data stack. <code>..</code> aligns memory to the nearest word by padding with nops. <code>@+ !p ..</code> is the instruction word that will be placed on the stack. It is meant to be executed by the neighbor in its right port and what it does there is to fetch the next piece of data, increment the data pointer, and send the data back to the neighbor listening on the right port. Finally <code>!b @b ;</code> will be executed on the local node to send the instruction word to its neighbor and receive the data word being sent back. That was a lot of words to about a small amount of code, but this code must be understood for the rest of the program to make any sense.
</p><p>The main program <code>go</code> first initalizes the a and b registers to point left and right. Then the right neighbor is told to execute <code>dup or a! ..</code> which initializes the data pointer by putting a zero into a for the first table reading. The rest of the word is a for next loop that runs 64 times. Three words are fetched from the neighbor to the left, the top two are added, <code>get</code> fetches a constant from the right and that's added with <code>+c</code>, resolving the accumulated carry. Now we save the value of <code>a</code> on the return stack because <code>rotate</code> is going to change the a register. <code>@</code> fetches the rotation amount from our neighbor to the left and the rotation is performed. The result is added via <code>+c</code> to what was left on the stack earlier and <code>a</code> is restored in order to send the result back to the left neighbor for storage.
</p><p>
</p><table border="4" frame="border" rules="none">
<tbody><tr>
<td><br><code>206</code><code> high constant generator and adder</code><code><br><br></code><code>rotate</code><code> shift right via +* and partner node</code><code><br></code><code>to effect a</code><code> 32</code><code> bit rotation</code><code><br><br></code><code>+c</code><code> receive carry from low word and add in <br></code><br></td>
<td> </td>
<td>846 list
<br><code>206</code><code> high constant generator and adder</code><code><br></code><code>14</code><code> org</code><code><br>rotate</code><code> 014</code><code> ni-n</code><code> up b! dup dup or</code><code><br> </code><code> a! push push a pop pop</code><code><br> </code><code> -if - push push @b pop !b pop then</code><code><br> </code><code> for +* unext !b drop @b</code><code><br> </code><code> a 2/ 2/</code><code> FFFF</code><code> and or ;</code><code><br>+c</code><code> 022</code><code> nn-n</code><code> + up b! @b . +</code><code> FFFF</code><code> and ;</code><code><br></code><code>027 <br></code><br></td>
</tr>
</tbody></table>
Here you see the definitions of <code>rotate</code> and <code>+c</code> for the high parts of those 32 bit operations.
<p><code>+c</code> can afford to execute <code>+</code> without a preceding <code>.</code> since the top two stack items will have been stable for a sufficient time in making the call. <code>b</code> is set to <code>up</code> and the accumulated carry is retrieved from node 106, the low partner. This carry is added and the result is clipped to 16 bits.
</p><p><code>rotate</code> begins with some initializations. <code>b</code> is set to <code>up</code> in anticipation of swapping bits with the partner node. <code>dup dup or</code> puts a zero on the stack, which is then placed into the a register and into the S register, the second location on the data stack. The rotation amount is on top of the stack. If it's negative that's a signal that we want to rotate by more than 16 places. The partner nodes exchange their T registers in this case. That's equivalent to a rotation of 16 places. Also the rotation amount is inverted via <code>-</code> to get the number of places left to rotate the number. The resulting number is pushed onto the return stack by <code>for</code> as a loop counter. <code>for +* unext</code> loop shifts T into A repeatedly. Finally the T values are swapped between partners and ored with the A values after shifting right twice via <code>2/ 2/</code> <code>ffff</code> <code>and</code> to construct the rotated number.
</p><p>
</p><table border="4" frame="border" rules="none">
<tbody><tr>
<td><br><code>106</code><code> low constant generator and adder</code><code><br><br></code><code>rotate</code><code> shift right via +* and partner node</code><code><br></code><code>to effect a</code><code> 32</code><code> bit rotation</code><code><br><br></code><code>+c</code><code> send carry to high word and mask off <br></code><br></td>
<td> </td>
<td>848 list
<br><code>106</code><code> low constant generator rotator and adder</code><code><br></code><code>14</code><code> org</code><code><br>rotate</code><code> 014</code><code> ni-n</code><code> up b! dup dup or a!</code><code><br> </code><code> push push a pop pop</code><code><br> </code><code> -if - push !b @b pop then</code><code><br> </code><code> for +* unext @b push !b drop pop</code><code><br> </code><code> a 2/ 2/</code><code> FFFF</code><code> and or ;</code><code><br>+c</code><code> 022</code><code> nn-n</code><code> + dup dup or push ..</code><code><br> </code><code> -if pop</code><code> 2</code><code> or push then 2*</code><code><br> </code><code> -if pop</code><code> 1</code><code> or push then 2/</code><code><br> </code><code> FFFF</code><code> and pop up b! !b ;</code><code><br></code><code>031 <br></code><br></td>
</tr>
</tbody></table>
<code>rotate</code> and <code>+c</code> are defined differently for the low partner.
<p><code>+c</code> still does the addition. The carry has accumulated in the high two bits of an 18 bit word, and we need it in the low two bits. We could have shifted right with <code>15 for 2/ unext</code> <code>ffff</code> <code>and</code>. This takes less code space but a longer time to execute. Instead the carry was constructed by checking the top two bits one at a time.
</p><p><code>rotate</code> is different only in that the high partner sends before receiving while the low partner receives before sending.
</p><table border="4" frame="border" rules="none">
<tbody><tr>
<td><br><code>205 105</code><code> md5 buffer code</code><code><br>round</code><code> send b , send func+a , pass msg ,</code><code><br></code><code>receive new a and store it in md5 buffer</code><code><br><br></code><code>must patch the address where f' is called</code><code><br></code><code>see yellow</code><code> 2E</code><code> ,</code><code> and gray</code><code> 2E</code><code><br><br></code><code>note that</code><code> +or</code><code> is a</code><code> 16</code><code> bit operation <br></code><br></td>
<td> </td>
<td>852 list
<br><code>205 105</code><code> md5 buffer code</code><code> 0</code><code> org</code><code> 0</code><code> ,</code><code> 0</code><code> ,</code><code> 0</code><code> ,</code><code> 0</code><code> ,</code><code><br>prep</code><code> 004</code><code> -3</code><code> right b!</code><code> 3</code><code> dup dup or a! ;</code><code><br>toss</code><code> 008</code><code> prep for @+ !b unext ;</code><code><br>grab</code><code> 00B</code><code> prep for @b !+ unext ;</code><code><br>clip</code><code> 00E</code><code> a</code><code> 3</code><code> and a! ;</code><code><br>f'</code><code> 011</code><code> xyz-n</code><code> push over - push and pop pop and</code><code><br>+or</code><code> 014</code><code> nn-n</code><code> over</code><code> FFFF</code><code> or and or ;</code><code><br>g'</code><code> 017</code><code> xyz-n</code><code> a! push a and pop a - and +or ;</code><code><br>h'</code><code> 01B</code><code> xyz-n</code><code> or or ;</code><code><br>i'</code><code> 01C</code><code> xyz-n</code><code> a! push a - +or pop or ;</code><code><br>pass</code><code> 01F</code><code> right b! @b</code><code></code><code> send</code><code> left b! !b ;</code><code><br>round</code><code> 023</code><code> 2E</code><code> a! ! dup dup or a!</code><code><br> </code><code> 15</code><code> for @+ clip @+ clip</code><code><br> </code><code> dup send @+ clip @+ clip</code><code><br> </code><code> a push ..</code><code> 02E</code><code> f' . + pop a!</code><code><br> </code><code> send pass pass @b !+</code><code><br> </code><code> @+ drop @+ drop clip next ;</code><code><br>md5</code><code> 038</code><code><br> </code><code> @p round f' @p round g'</code><code><br> </code><code> @p round h' @p round ; i'</code><code><br></code><code>040</code><code> <br></code><br></td>
</tr>
</tbody></table>
The exact same code is compiled for both nodes 205 and 105. A temporary message digest buffer of four words is reserved at address 0. The words <code>toss</code> and <code>grab</code> are used to receive the current hash from node 103 at the beginning of a 64 octet block and to send it back toward 103 at the end. Both words are executed remotely by the 204, 104 pair of nodes because there isn't room here for that much code. <code>clip</code> ensures that the a register will wrap around from 3 to 0 so it always points into the local md5 buffer.
<p>The four md5 bitwise functions are then defined followed by <code>pass</code> and <code>send</code> which are used to pass data from right to left or just to send data to the left. Note that <code>pass</code> falls through into <code>send</code>. There are four rounds for each 64 octet message block. The word <code>round</code> first patches the current function into address <code>02e</code> and yes, this is self-modifying code. The code just fits into 64 words of RAM this way. Then <code>round</code> loops 16 times where it fetches the current hash values, sending the "b" hash value on to the right neighbor before executing the current function and adding it to the "a" hash value. This sum is sent to the right neighbor. Then the message fragment and rotation amount are received from the left and passed on to the right. The right neighbor does its calculations and sends a result back, which is fetched and stored here back to the temporary hash buffer. The hash buffer pointer in the a register is then incremented twice and kept within the range 0-3 by <code>@+ drop @+ drop clip</code> before moving on to the next step of this round.
</p><p>Back to the patching. In the word <code>md5</code> you see phrases such as <code>@p round f'</code>. The <code>@p</code> is compiled into slot 0 with the call to <code>round</code> in slot 1. The next word in memory will contain a call to <code>f'</code>. This call to f' will not be executed here. It is simply data to be stored into address 2e where it will be executed later.
</p><table border="4" frame="border" rules="none">
<tbody><tr>
<td><br><code>204 104</code><code> message buffer code</code><code><br><br></code><code>msg gets both neighbor pairs started</code><code><br></code><code>205,105 and 206,106</code><code><br></code><code>it also computes the sequence in which</code><code><br></code><code>the message buffer is accessed <br></code><br></td>
<td> </td>
<td>854 list
<br><code>204 104</code><code> message buffer code</code><code> 0</code><code> org</code><code><br></code><code>0</code><code> ,</code><code> 0</code><code> ,</code><code> 0</code><code> ,</code><code> 0</code><code> ,</code><code> 0</code><code> ,</code><code> 0</code><code> ,</code><code> 0</code><code> ,</code><code> 0</code><code> ,</code><code><br></code><code>0</code><code> ,</code><code> 0</code><code> ,</code><code> 0</code><code> ,</code><code> 0</code><code> ,</code><code> 0</code><code> ,</code><code> 0</code><code> ,</code><code> 0</code><code> ,</code><code> 0</code><code> ,</code><code><br>msgs</code><code> 010</code><code> ni</code><code> pop a! @+ @+ a push</code><code><br> </code><code> 15</code><code> for dup a! @ !b over . +</code><code><br> </code><code> F</code><code> and left a! @ !b next drop drop ;</code><code><br>msg</code><code> 01C</code><code> right b! @p ..</code><code> /</code><code> @p b! @p ..</code><code> /</code><code><br> </code><code> !b left !b @p</code><code> /</code><code> go</code><code> /</code><code><br> </code><code> !b @p !b @p</code><code> /</code><code> !b grab</code><code> /</code><code> md5</code><code> /</code><code><br> </code><code> left a!</code><code> 3</code><code> dup push</code><code><br> </code><code> for @ !b unext !b</code><code><br> </code><code> msgs</code><code> 1</code><code> ,</code><code> 0</code><code> ,</code><code> f's</code><code><br> </code><code> msgs</code><code> 5</code><code> ,</code><code> 1</code><code> ,</code><code> g's</code><code><br> </code><code> msgs</code><code> 3</code><code> ,</code><code> 5</code><code> ,</code><code> h's</code><code><br> </code><code> msgs</code><code> 7</code><code> ,</code><code> 0</code><code> ,</code><code> i's</code><code><br> </code><code> @p !b ..</code><code> /</code><code> toss</code><code> /</code><code><br> </code><code> begin @b ! unext ;</code><code><br></code><code>039</code><code> <br></code><br></td>
</tr>
</tbody></table>
Again, the same code is compiled for both node 204 and node 104.
<p>Each node has its own half of the message buffer. Node 204 has the upper 16 bits of each of 16 32 bit words of message. Node 104 has the lower 16 bits of each 32 bit word. The buffer is filled remotely by nodes 202 and 102 before this node is started up. The word <code>msg</code> is kicked off by the neighbor to the left. Nodes 204 and 104 kick off both their neighbors to the right with <code>grab</code> and then <code>md5</code> and their neighbors to the left with <code>go</code>.
</p><p>The word <code>msgs</code> begins by reading the two following constants via <code>pop a! @+ @+ a push</code>. The address of the first constant is popped from the return stack and the incremented address is pushed back onto the return stack to continue execution just after the constants. This may seem convoluted but it saves a bit of memory over using conventional constant values with @p. These numbers are used to calculate the current message index at each step of the algorithm. For each round the message index starts at a specified number for that round and is incremented each step by that round's specified increment. The index thus calculated is used to fetch the current chunk of message and send it on to the right for processing. The rotation amount is then fetched from the left neighbor and passed on to the right neighbor.
</p><p>Finally after all four rounds have run, the right neighbor is told to run <code>toss</code> in order to send the temporary hash back to node 103, and this node passes the values on.
</p><table border="4" frame="border" rules="none">
<tbody><tr>
<td><br><code>203</code><code> rots generator</code><code><br><br></code><code>rotation amounts are encoded as</code><code><br><br></code><code>sx</code><code> 1111</code><code> 1111</code><code> 1111</code><code> 1111</code><code><br></code><code>col-3 col-2 col-1 col-0 at address zero.</code><code><br></code><code>where</code><code> s</code><code> signals need to swap words and</code><code><br></code><code>invert this value for rotations greater</code><code><br></code><code>than 16 bits in the third slot and</code><code> x</code><code> is don't <br>care.</code><code><br><br></code><code>this node passes the rotation amounts to</code><code><br></code><code>both the high word row and the low word row</code><code><br><br> <br></code><br></td>
<td> </td>
<td>856 list
<br><code>203</code><code> rots generator</code><code> 0</code><code> org</code><code><br></code><code>29E38</code><code> ,</code><code> B16A</code><code> ,</code><code> 28F4B</code><code> ,</code><code> A059</code><code> ,</code><code><br>send</code><code> n</code><code> dup left a! ! up a! ! ;</code><code><br>keep</code><code> 009</code><code> up b! left a!</code><code> 3</code><code> for @ !b unext ;</code><code><br>put</code><code> 00F</code><code> up b! left a!</code><code> 3</code><code> for @b ! unext ;</code><code><br>ncol</code><code> 015</code><code> for 2/ unext</code><code><br>0col</code><code> 017</code><code> F</code><code> and ;</code><code></code><code> 1col</code><code> 019</code><code> 3</code><code> ncol ;</code><code><br>2col</code><code> 01B</code><code> dup push</code><code> 7</code><code> ncol pop</code><code><br> </code><code> -if drop - dup then drop ;</code><code><br>3col</code><code> 021</code><code> 11</code><code> ncol - ;</code><code><br>jump</code><code> 024</code><code> i</code><code> pop + push ;</code><code><br>rots</code><code> 025</code><code> i</code><code> dup 2/ 2/ 2/ 2/ a! @ over</code><code><br> </code><code> 3</code><code> and jump 0col ; 1col ; 2col ; 3col ;</code><code><br>rotgen</code><code> 02E</code><code> left a! @p ..</code><code> /</code><code> msg</code><code> /</code><code> ! put</code><code><br> </code><code> 0 63</code><code> for dup rots send</code><code> 1</code><code> . + next</code><code><br> </code><code> drop keep ;</code><code><br></code><code>03B</code><code> <br></code><br></td>
</tr>
</tbody></table>
Nodes 203 and 103 have very different functions. They should not be considered partner nodes as all the others up to now have been. During each of the 64 steps of the md5 algorithm node 203 calculates the rotation amount needed for <code>rotate</code> in nodes 106 and 206. The rotation amount is passed on to node 204 which passes it to 205 which passes it to 206 where it is used. Also 203 passes the rotation amount to node 103 which then passes it on to 106 via 104 and 105. The only function of node 103 during the 64 steps is as a wire, passing data from 203 to 104.
<p>Rotation amounts are encoded into the first four words of node 203. Each of the four words contains the encoded rotation amounts for one round of the algrithm. Within one round there are four rotation amounts to be cycled through. In general the rotation amount is encoded as a single nibble. Only 16 positions of rotation can be encoded in a nibble. It happens that the first two rotation amounts are always less than 16 and the last one is always greater than 16. The third amount is sometimes less, sometimes greater, and once equal to 16. If the third amount is greater than 16 that is encode by setting bit 17. When the rotation amount is greater than 16 that amount is inverted before being sent on to the 206 106 pair, to signal that 16 bit words must be swapped to effect rotation by 16 before performing the rest of the rotation.
</p><p>The first word of block 203 is <code>send</code>, which sends the same data word (rotation amount) to both neighbor nodes 103 and 204. <code>keep</code> and <code>put</code> are responsible for sending and receiving the temporary hash values from 103 to 205 in the beginning, and from 205 back to 103 in the end. The words <code>0col 1col 2col 3col</code> each extract a nibble from the coded word, inverting the word where appropriate, and <code>jump</code> implements a computed goto so that the appropriate <code>ncol</code> word can be executed by number. The word <code>rots</code> transforms an index, 0-63, into a rotation amount to be sent on to the pair 206 106. Bits in the index are used to decide which coded word to fetch and then which nibble to decode. A lot of work, but it would burn a whole 64 word node to simply look up the value directly.
</p><p><code>rotgen</code> is the main program for this node. It starts by telling neighbor to run <code>msg</code>. Then it acts as a wire via <code>put</code> passing the temporary hash values from 103 over to 204 which passes them to 205. Now we go into a for next loop for 64 iterations, calculating the rotation amount and sending it on. At last the work <code>keep</code> is executed to act as a wire passing the currently calculated hash values back to 103.
</p><p>
</p><table border="4" frame="border" rules="none">
<tbody><tr>
<td><br><code>103</code><code> save and add abcd back</code><code><br><br></code><code>the current message digest is first sent to</code><code><br></code><code>the md5 node and finally added back into</code><code><br></code><code>this buffer <br></code><br></td>
<td> </td>
<td>858 list
<br><code>103</code><code> save and add abcd back</code><code> 0</code><code> org</code><code><br></code><code>2301</code><code> ,</code><code> 6745</code><code> ,</code><code> AB89</code><code> ,</code><code> EFCD</code><code> ,</code><code><br></code><code>DCFE</code><code> ,</code><code> 98BA</code><code> ,</code><code> 5476</code><code> ,</code><code> 1032</code><code> ,</code><code><br></code><code>put</code><code> 008</code><code> dup dup or a!</code><code> 3</code><code> for</code><code><br> </code><code> left b! @+ !b up b! @+ !b next ;</code><code><br></code><code>sum</code><code> 012</code><code> dup dup or a!</code><code> 3</code><code> for</code><code><br> </code><code> left b! @b @ . + dup</code><code> FFFF</code><code> and !+</code><code><br> </code><code> up b! @b @ . + over 2*</code><code><br> </code><code> -if drop</code><code> 1</code><code> . + dup then drop</code><code><br> </code><code> FFFF</code><code> and !+ next</code><code> ;</code><code><br>sums</code><code> 025</code><code> left a! @p ..</code><code> /</code><code> msg</code><code> /</code><code> ! put</code><code><br> </code><code> left a!</code><code> 63</code><code> for @b ! unext sum ;</code><code><br></code><code>02F</code><code> <br></code><br></td>
</tr>
</tbody></table>
Node 103 is used to house the calculated md5 hash values between message blocks. The first 8 words of memory are used to buffer this data. The first word defined, <code>put</code> is meant to fetch each word of the buffer in sequence and send it to the apppropriate row, high or low. The word <code>sum</code> is used at the end of a message block in order to add the new 32 bit hash values to the old ones that were saved here. First the a register is initialized to zero with the idiom <code>dup dup or a!</code> and then for each 32 bit hash value the 16 bit halves are fetched from up and left neighbors and added with carry resolved to the hash values preserved here at the beginning of the current message block.
<p><code>sums</code> ties this all together beginning by pointing the a register left and telling the left neighbor to run <code>msg</code>. Then it runs <code>put</code>, tranferring the current hash values to nodes 205 and 105. During the 64 steps of the algorithm this node acts as a wire, passing rotation amounts on. Finally the word <code>sum</code> is executed to receive new hash values and add them to the preserved old values.
</p><p>The ten nodes mentioned so far implement the complete md5 algorithm for a single 64 octet message buffer. Once the buffer in nodes 204 and 104 has been filled, only these nodes operate.
</p><table border="4" frame="border" rules="none">
<tbody><tr>
<td><br><code>202</code><code> main control</code><code><br><br></code><code>nodes</code><code> 202</code><code> and</code><code> 102</code><code> setup and control</code><code><br></code><code>the others</code><code><br><br></code><code>only these two nodes need to be customized</code><code><br></code><code>in order to feed in the message and</code><code><br></code><code>read out the digest <br></code><br></td>
<td> </td>
<td>860 list
<br><code>202</code><code> main control</code><code> 0</code><code> org</code><code><br>code</code><code> 203</code><code> left b!</code><code> 20</code><code> for @p !b unext ..</code><code><br> </code><code> 204</code><code> dup dup or a!</code><code> 15</code><code> for</code><code><br> </code><code> @p !+ unext ..</code><code> 009</code><code> --l- ; r--- ;</code><code> 00B</code><code><br>highs</code><code> 00B</code><code> right b! dup dup or a!</code><code><br> </code><code> 8</code><code> for @+ !b unext a push up a!</code><code><br> </code><code> 15</code><code> for @ !b unext pop a!</code><code><br> </code><code> @+ !b @+ !b .. @p !b ;</code><code> /</code><code> rotgen</code><code> /</code><code><br></code><code>01A</code><code> <br></code><br></td>
</tr>
</tbody></table>
Nodes 202 and 102 are fancy wire nodes passing the message stream in to nodes 204 and 104. Node 202 here is mostly wire. After starting port pumps in neighbor 203 and its neighbor 204 it passes the 16 bit high parts of the 16 32 bit message chunks in from 102 to 204. The word <code>code</code> is really a stream of code to be sent to and executed in the left port by the neighbor, node 203. Some of the code in the stream is in turn sent to 203's neighbor 204 to be executed there.
<p>The first line, labeled <code>203</code>, is executed by node 203 in it's right port. It causes 203 to point its b register to its left port and run a port pump, <code>for @p !b unext ..</code> through 21 iterations. This causes the next bit of code to be executed in the left port of node 204, which puts a zero into the a register and runs another port pump, <code>for @p !+ unext ..</code> for 16 iterations, ultimately storing the 16 high 16 bit parts of the message block into node 204. Node 204 ends up jumping left and node 203 jumps right to await further instructions from 202. The final instruction send is the call to <code>rotgen</code> which kicks off node 203 who in turn kicks of the rest of the high row to run 64 steps of the md5 algorithm.
</p><p>
</p><table border="4" frame="border" rules="none">
<tbody><tr>
<td><br><code> <br></code><br></td>
<td> </td>
<td>862 list
<br><code>102</code><code> main control</code><code> 0</code><code> org</code><code><br>code</code><code> 103</code><code> left b!</code><code> 20</code><code> for @p !b unext ..</code><code><br> </code><code> 104</code><code> dup dup or a!</code><code> 15</code><code> for</code><code><br> </code><code> @p !+ unext ..</code><code> 009</code><code> --l- ; r--- ;</code><code> 00B</code><code><br>half</code><code> p</code><code> push down a! @ @</code><code> 7</code><code> for 2* unext</code><code><br> </code><code> or pop a! ! ;</code><code><br>lows</code><code> 012</code><code> up b! @p ..</code><code> /</code><code> highs</code><code> /</code><code> !b</code><code><br> </code><code> right b!</code><code> dup dup or a!</code><code><br> </code><code> 8</code><code> for @+ !b unext a push</code><code><br> </code><code> 15</code><code> for right half up half next</code><code><br> </code><code> pop a! @+ !b @+ !b .. @p !b ;</code><code> /</code><code> sums</code><code> /</code><code><br></code><code>027</code><code> <br></code><br></td>
</tr>
</tbody></table>
Node 102 has a little more work to do than 202 did. It receives the 64 octets of a message buffer from node 002 and assembles them into the high and low 16 bit words of message chunks before sending those on to nodes 202 and 103, eventually to be stored in 204 and 104. The word <code>code</code> is identical to that already mentioned in node 202 and sets up similar port pumps in nodes 103 and 104.
<p><code>half</code> does the work of assembling a 16 bit word from two octets, then sends it to the port passed as a parameter. The main program for this node, <code>lows</code> first starts node 202 running <code>highs</code>. Then it sets up the port pumps in nodes 103 and 104 before reading in octets from 002, assembling them into 16 bit words and sending those on to the high row and the low row. Its final act is to tell node 103 to run <code>sums</code> in order to add the new hash values to the old ones saved in node 103.
</p><p>
</p><table border="4" frame="border" rules="none">
<tbody><tr>
<td><br><code>002 main interface</code><code><br><br></code><code>data entry point <br></code><br></td>
<td> </td>
<td>864 list
<br><code>002 main interface</code><code> 0</code><code> org</code><code> 0</code><code> ,</code><code> 0</code><code> ,</code><code> 0</code><code> ,</code><code><br>add</code><code> 003</code><code> n-n</code><code> @ . + dup</code><code> FFFF</code><code> and !+ ;</code><code><br>count</code><code> 006</code><code> 1</code><code> a!</code><code> 8</code><code> add 2* -if</code><code><br> </code><code> drop</code><code> 1</code><code> add then drop ;</code><code><br>get</code><code> 00F</code><code> @ -if dup or a!</code><code> 80</code><code> ; then</code><code><br> </code><code> a if count then a! ;</code><code><br>octets</code><code> 016</code><code> n</code><code> for get !b next ;</code><code><br>ablk</code><code> 01A</code><code> n</code><code> 55</code><code> octets</code><code><br> </code><code> a if drop</code><code> 7</code><code> octets ; then drop</code><code><br> </code><code> @+ drop a for</code><code><br> </code><code> @+ dup</code><code> FF</code><code> and !b</code><code> 7</code><code> for 2/ unext</code><code><br> </code><code> FF</code><code> and !b next</code><code><br> </code><code> 0</code><code> a!</code><code> 3</code><code> for @ !b unext warm ;</code><code><br>start</code><code> 031</code><code> here boot</code><code><br> </code><code> down b! right a!</code><code><br> </code><code> begin @p !b ..</code><code> /</code><code> lows</code><code> /</code><code> ablk end</code><code><br></code><code>039 <br></code><br></td>
</tr>
</tbody></table>
Node 002 has the job of receiving message octets delimited by a negative number. It counts the message bits and in the last message block, after receiving the delimiter, the message is padded and the bit count is inserted. As far as neighbor 102 is concerned 002 just sends blocks of 64 message octets.
<p>The first word, <code>add</code> is part of counting message bits. It fetches the value pointed to by the a register, then adds it to what was already on the stack. The result is clipped to 16 bits before being stored back into where a points. The a register is incremented for the next addition and the sum is left on the stack, including any accumulated carry in the upper two bits. Here's how <code>count</code> uses <code>add</code> to count bits in the message. Two words are reserved and initialized to zero at addresses 1 and 2 in memory. The word <code>count</code> adds 8 to the low word at address 1. If bit 16 indicates a carry, then 1 is added to address 2.
</p><p>The word <code>get</code> is used to get the next octet. Normally the a register points to the right point and the octet is fetched from there. If the octet is not negative then the bit count is incremented by eight and the octet is left on the data stack. However if the octet was negative, indicating end of message, the top of stack is changed to zero via <code>dup or</code> and stored into the a register and an <code>80</code> is returned. <code>80</code> is the padding octet, a one bit followed by zeros. Now the a register points to address 0 which contains a zero, so further calls to <code>get</code> will simply return zero.
</p><p><code>octets</code> is a factor used within <code>ablk</code> that allows us to say <code>55 octets</code> in order to read in the first 56 bytes, and <code>7 octets</code> for the next 8 bytes when end of message has not yet been received. After the first 56 octets have been read with <code>get</code> the a register will tell us if end of message has been received, by containing a zero. When the a register is zero we execute the following code, <code>@+ drop a for</code>. The a register contains zero to begin with. Its incremented to contain 1, which is fetched as parameter to for. This loop then executes twice to fetch and send on the bit count stored at addresses 1 and 2 as four octets. Then the a register is set back to zero so that <code>3 for @ !b unext</code> will finish padding the message block with zeros. At this point the md5 algorithm is finished, as far as node 002 is concerned, so it jumps to warm where it awaits new instructions. The final md5 hash can now be extracted from node 103.
</p><p>
</p><p></p><hr><p>
</p><h2>To be continued...</h2>
<ul>
<li>Testing strategy
</li><li>Timing estimation and measurement
</li><li>Energy estimation and measurement
</li><li>Comparison with other implentations
</li><li>Opportunities for improvement
</li></ul>
</body></html>