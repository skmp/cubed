<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<title>
		</title>
</head>
	<body>
		<div id="page_0">
			<div>
				<div>
					<div>GreenArrays<sup>® </sup></div>
					Product Data Book DB001 Revised 11/07/17
					F18A
					Technology
					Reference
					This manual fully documents the instruction set and the generic I/O facilities incorporated in the
					F18A computer and, therefore, in chips comprised of them.
					This manual is supplemented by lectures at the arrayForth Institute and by examples in the
					Application Notes and other documentation available from our company.
					After understanding the F18A technology, the next step is to study the Data Book for the particular
					chip of interest. The Chip Data Book will show the configuration of the node array, the I/O facilities
					and interconnections in that particular chip, and the ROM content for each node. In addition the
					chips are characterized physically, electrically and thermally.
					For people accustomed to reading hardware manuals this should be refreshingly brief, as befits an
					uncommonly simple architecture. We have made an effort to avoid redundancy in the interest of
					brevity; as a result, the information density is high, warranting a careful reading. More than one
					reader has glossed over sections that did not seem important only to find later that they were very
					important indeed!
					Your satisfaction is very important to us! Please familiarize yourself with our website at
					<div><a href="http://www.greenarraychips.com/" target="_blank">http://www.greenarraychips.com/</a><a href="http://www.greenarraychips.com/" target="_blank">. </a>This will lead you to the latest software and documentation as </div>
					well as resources for solving problems and contact information for obtaining help or information in
					real time.
				</div>
			</div>
		</div>
		<div id="page_1">
			<div>
				<div>
					Contents
					<div><a href="#3_0">1. </a></div>
					<div><a href="#3_0">Introduction ..............................................................................3 </a></div>
					<div><a href="#3_1">1.1 </a></div>
					<div><a href="#3_2">1.2 </a></div>
					<div><a href="#3_3">1.2.1 </a></div>
					<div><a href="#3_4">1.2.2 </a></div>
					<div><a href="#3_5">1.2.3 </a></div>
					<div><a href="#3_6">1.2.4 </a></div>
					<div><a href="#3_1">Status of Data Give</a><a href="#3_1">n</a><a href="#3_1">.</a><a href="#3_1">.......................................................................................3 </a></div>
					<div><a href="#3_2">Documentation Conventions............................................................................3 </a></div>
					<div><a href="#3_3">Numbers .............................................................................................................. 3 </a></div>
					<div><a href="#3_4">Node coordinates................................................................................................. 3 </a></div>
					<div><a href="#3_5">Register names..................................................................................................... 3 </a></div>
					<div><a href="#3_6">Bit Numbering...................................................................................................... 3 </a></div>
					<div><a href="#4_0">2. </a></div>
					<div><a href="#4_0">The F18A Computer ...................................................................4 </a></div>
					<div><a href="#5_0">2.1 </a></div>
					<div><a href="#5_1">2.2 </a></div>
					<div><a href="#5_2">2.3 </a></div>
					<div><a href="#5_0">After Reset.......................................................................................................5 </a></div>
					<div><a href="#5_1">Memory Addressing.........................................................................................5 </a></div>
					<div><a href="#5_2">Instruction Set .................................................................................................5 </a></div>
					<div><a href="#6_0">Instruction Word Format ..................................................................................... 6 </a></div>
					<div><a href="#6_1">Stack Operation ................................................................................................... 6 </a></div>
					<div><a href="#7_0">Arithmetic, Logic and Register Manipulation ...................................................... 7 </a></div>
					<div><a href="#8_0">Memory Read and Write ..................................................................................... 8 </a></div>
					<div><a href="#8_1">Transfer of Program Contro</a><a href="#8_1">l</a><a href="#8_1">.</a><a href="#8_1">............................................................................... 8 </a></div>
					<div><a href="#9_0">Fine Points .......................................................................................................9 </a></div>
					<div><a href="#9_1">Execution Time..................................................................................................... 9 </a></div>
					<div><a href="#9_2">Prefetch considerations ....................................................................................... 9 </a></div>
					<div><a href="#9_3">Best Practice</a><a href="#9_3">s</a><a href="#9_3">.</a><a href="#9_3">...................................................................................................... 9 </a></div>
					<div><a href="#9_4">Compiling Instructions Yourself ........................................................................... 9 </a></div>
					<div><a href="#6_0">2.3.1 </a></div>
					<div><a href="#6_1">2.3.2 </a></div>
					<div><a href="#7_0">2.3.3 </a></div>
					<div><a href="#8_0">2.3.4 </a></div>
					<div><a href="#8_1">2.3.5 </a></div>
					<div><a href="#9_0">2.4 </a></div>
					<div><a href="#9_1">2.4.1 </a></div>
					<div><a href="#9_2">2.4.2 </a></div>
					<div><a href="#9_3">2.4.3 </a></div>
					<div><a href="#9_4">2.4.4 </a></div>
					<div><a href="#10_0">3. </a></div>
					<div><a href="#10_0">F18A I/O Facilities....................................................................10 </a></div>
					<div><a href="#10_1">3.1 </a></div>
					<div><a href="#11_0">3.2 </a></div>
					<div><a href="#11_1">3.3 </a></div>
					<div><a href="#11_2">3.3.1 </a></div>
					<div><a href="#11_3">3.3.2 </a></div>
					<div><a href="#12_0">3.4 </a></div>
					<div><a href="#12_1">3.4.1 </a></div>
					<div><a href="#12_2">3.4.2 </a></div>
					<div><a href="#12_3">3.4.3 </a></div>
					<div><a href="#13_0">3.5 </a></div>
					<div><a href="#10_1">The io Registe</a><a href="#10_1">r</a><a href="#10_1">.</a><a href="#10_1">..............................................................................................10 </a></div>
					<div><a href="#11_0">Suspension.....................................................................................................11 </a></div>
					<div><a href="#11_1">Communication Ports ....................................................................................11 </a></div>
					<div><a href="#11_2">Multiport Operation</a><a href="#11_2">s</a><a href="#11_2">.</a><a href="#11_2">........................................................................................ 11 </a></div>
					<div><a href="#11_3">Port Execution.................................................................................................... 11 </a></div>
					<div><a href="#12_0">Nodes with GPIO Pins ....................................................................................12 </a></div>
					<div><a href="#12_1">Wakeup Pins ...................................................................................................... 12 </a></div>
					<div><a href="#12_2">Shared (Read-only) Pin</a><a href="#12_2">s</a><a href="#12_2">.</a><a href="#12_2">.................................................................................... 12 </a></div>
					<div><a href="#12_3">Phantom Wakeup Signals .................................................................................. 12 </a></div>
					<div><a href="#13_0">Parallel Bus Support ......................................................................................13 </a></div>
					<div><a href="#13_1">SERDES Nodes................................................................................................13 </a></div>
					<div><a href="#14_0">Analog Nodes ................................................................................................14 </a></div>
					<div><a href="#13_1">3.6 </a></div>
					<div><a href="#14_0">3.7 </a></div>
					<div><a href="#15_0">4. </a></div>
					<div><a href="#15_0">Revision History.......................................................................15 </a></div>
					Introduction
					2
				</div>
			</div>
		</div>
		<div id="page_2">
			<div>
				<div>
					1. Introduction
					The F18 technology consists of small, simple computers and several types of versatile, software defined I/O. Our chips
					are configured as arrays of the F18 computers with appropriate selections of I/O types.
					An F18 computer is a physically small, very fast, energy-efficient and inexpensive 18-bit machine. Each F18 is self-
					contained as a complete system, with its own RAM, ROM, stacks, registers, and where appropriate external I/O. The
					F18 computers in an array operate independently and asynchronously, communicating with each other using efficient
					internal communication ports.
					This book will familiarize you with the architecture, internal structure, and use of the computers and I/O of chips built
					from F18A technology. Please refer to the data books for specific chips using this technology to learn their exact
					configurations, pin-outs, ROM content and electrical characteristics. The current editions of these, along with many
					other relevant documents and application notes as well as the current edition of this document, may be found on our
					<div>website a<a href="http://www.greenarraychips.com/" target="_blank">t </a><a href="http://www.greenarraychips.com/" target="_blank">http://www.greenarraychips.com </a>. It is always advisable to ensure that you are using the latest documents </div>
					before starting work.
					1.1 Status of Data Given
					The data given herein are PRODUCTION. Electrical and timing values are illustrative only. Otherwise, the subject
					matter of this book is the architecture, instruction set, and programming of the F18A computers and I/O, which are
					fixed by design. Future revisions of this book may document upward-compatible enhancements of the F18A
					programming model.
					1.2 Documentation Conventions
					1.2.1 Numbers
					Numbers are written in decimal unless otherwise indicated. Hexadecimal values are indicated by explicitly writing
					“hex” or by preceding the number with the lowercase letter “x”. In colorForth coding examples, hexadecimal values
					are italicized and darkened.
					1.2.2 Node coordinates
					Each GreenArrays chip is a rectangular array of nodes, each of which is an F18 computer. By convention these arrays
					are visualized as seen from the top of the silicon die, which is normally the top of the chip package, oriented such that
					pin 1 is in the upper left corner. Within the array, each node is identified by a three or four digit number denoting its
					Cartesian coordinates within the array as yxx or yyxx with the lower left corner node always being designated as node
					000. Thus, for a GA144 chip whose computers are configured in an array of 18 columns and 8 rows, the numbers of the
					nodes in the lower right, upper left, and upper right corners are 017, 700, and 717 respectively.
					1.2.3 Register names
					Register names in prose may be used with or without the word "register" and are usually shown in a bold font and
					capitalized where necessary to avoid ambiguity, such as for example the registers T S R I A B and IO or io .
					1.2.4 Bit Numbering
					Binary numbers are visualized as a horizontal row of bits, numbered consecutively right to left in ascending significance
					<div>with the least significant bit numbered zero. Thus bit n has the binary value 2<sup>n</sup>. The notation P9 means bit 9 of register </div>
					P, whose binary value is x200, and T17 means the sign (high order) bit of 18-bit register T.
					<a name="3_0"> </a>
					<a name="3_1"> </a>
					<a name="3_2"> </a>
					<a name="3_3"> </a>
					<a name="3_4"> </a>
					<a name="3_5"> </a>
					<a name="3_6"> </a>
				</div>
			</div>
		</div>
		<div id="page_3">
			<div>
				<div>
					2. The F18A Computer
					Here is an introduction to the resources within each F18A computer. All elements are 18 bits wide unless otherwise noted.
					•
					•
					RAM: 18 bits wide, 64 words in each node.
					Local RAM (64x18) and ROM (64x18)
					I/O logic option for edge nodes
					Comm Ports (2, 3, 4 or 5)
					ROM: 18 bits wide, 64 words in each node.
					•
					•
					I/O logic may be present on any edge node of a chip.
					Communication Ports are configured based on position
					within the array (four for inner; three ports array edges; two for
					corners.) One additional port is optional.
					•
					IO control and status for communication ports and I/O
					IO Control &amp; Status Register
					Return Stack (8x18)
					logic.
					•
					Return Stack consists of 8 registers addressed circularly (no
					fixed top or bottom.) Pushing a word onto this stack makes it the
					new “top” item, overwriting the former “bottom” item. After
					popping 8 items, those 8 items are repeated.
					R
					•
					R extends this stack to 9 entries but only 8 are circular.
					Decrementer
					When used as a loop counter, R decrements toward zero.
					•
					P serves as a “program counter”, holding the address of the
					P (10)
					next word in the instruction stream. Within RAM or ROM, it is
					incremented after each word is fetched, circularly within whichever
					storage class it currently points to. When P addresses I/O space, it is
					not incremented. Bit P9 enables Extended Arithmetic Mode when
					set.
					Incrementer (7)
					A
					•
					A is a general purpose read/write address or data register.
					B (9)
					•
					B is a write only address register, containing on reset the
					I
					address of io register.
					Slot Mux
					T
					•
					I is the instruction register into which instruction words
					containing 1, 2, 3 or 4 opcodes are fetched for execution.
					•
					•
					T is the top word of a 10-element data stack.
					ALU
					The ALU (Arithmetic/Logic unit) performs unary operations
					on T, binary operations on S and T, or a multiply step involving S, T,
					and A as directed by opcodes. A carry latch is involved in some
					Extended Arithmetic mode instructions.
					S
					•
					S is the second word of a 10-element data stack.
					Data Stack (8x18)
					•
					Data Stack is 8 circularly addressed registers constituting
					<div>the third through 10<sup>th </sup>elements of a 10-element stack. </div>
					Figure 1 F18A Block Diagram
					The F18 Computer
					4
					<a name="4_0"> </a>
				</div>
			</div>
		</div>
		<div id="page_4">
			<div>
				<div>
					2.1 After Reset
					On chip reset, the following registers are initialized:
					P is set to the address configured in the chip layout. For F18A, this will always be either a multiport execute or will
					be ROM address x0aa.
					io is set to the state it would have after a program wrote x15555 into the register.
					B is set to the address of io.
					Stack pointers are set to the same initial condition on every reset.
					Other registers, stack contents, and RAM are not directly affected by reset.
					2.2 Memory Addressing
					<div>The F18A decodes a nine-bit memory address as shown in <a href="#5_3">Figure 2. </a></div>
					Address incrementing, when applied to A or P, continues
					Start
					x000
					x040
					x080
					x0C0
					x100
					End Address Space
					x03F RAM, 64 words
					x07F RAM x000-x03F repeated
					x0BF ROM, 64 words
					x0FF ROM x080-x0BF repeated
					x1FF I/O ports and registers
					from x03F to x040 but wraps from x07F to x000. The
					same process occurs with addresses in the ROM space.
					Incrementing does not occur at all when the address lies
					in the region of I/O ports and registers. Incrementing
					never affects bits P8 or P9. P9 has no effect on memory
					decoding; it simply enables the Extended Arithmetic
					Mode when set.
					Figure 2 Address Map
					2.3 Instruction Set
					<div>The F18 instruction set consists of 5-bit opcodes as summarized in <a href="#5_4">Figure 3: </a></div>
					Opcode Notes
					Opcode Notes
					;
					return
					+*
					multiply step
					ex
					execute (swap P and R)
					2*
					left shift
					name ; jump to name
					call to name
					unext loop within I (decrement R)
					2/
					—
					right shift (signed)
					invert all bits
					add (or add with carry)
					name
					+
					next
					if
					-if
					@p
					@+
					@b
					@
					!p
					!+
					!b
					!
					loop to address (decrement R)
					jump if T=0
					jump if T≥0
					literal (autoincrement P)
					fetch via A (autoincrement A)
					fetch via B
					and
					or
					exclusive or
					from R to T
					drop
					dup
					pop
					over
					a
					fetch via A
					fetch from register A
					nop
					from T to R
					store into register B
					store into register A
					store via P (autoincrement P)
					store via A (autoincrement A)
					store via B
					.
					push
					b!
					store via A
					a!
					Figure 3 Table of Opcodes
					<div>The shaded opcodes may be used in slot 3 of an instruction word (see <a href="#5_5">2.3.1 </a>below). Add (+) and multiply step (+*) </div>
					behave differently in Extended Arithmetic Mode.
					The F18A Computer
					5
					<a name="5_0"> </a>
					<a name="5_1"> </a>
					<a name="5_2"> </a>
					<a name="5_3"> </a>
					<a name="5_4"> </a>
					<a name="5_5"> </a>
				</div>
			</div>
		</div>
		<div id="page_5">
			<div>
				<div>
					2.3.1 Instruction Word Format
					Each F18A instruction word is subdivided into four possible slots for opcodes that are normally executed sequentially
					left to right when viewing the word as conventionally oriented with most significant bit to the left. Jump instructions
					may be written in slots 0, 1, or 2, and when they are encountered the remainder of the instruction word is interpreted
					<div>as an address field. This results in four possible instruction word formats as shown in <a href="#6_2">Figure 4: </a></div>
					Slot 0
					Slot 1
					Instruction 1
					Instruction 1
					Jump instruction
					Unused
					Slot 2
					Instruction 2
					Jump instruction
					Slot 3
					Instruction 3
					Destination
					Instruction 0
					Instruction 0
					Instruction 0
					Jump instruction
					Destination
					Destination
					17
					16
					15
					14
					13
					12
					11
					10
					9
					8
					7
					6
					5
					4
					3
					2
					1
					0
					Figure 4 Instruction word formats
					The n-bit destination address field simply replaces the n low order bits of the current (incremented) value of P at the
					time the jump instruction executes. Thus the scope of a slot 2 jump is very limited while a slot 0 jump can reach any
					addressable destination, and can control P9 to explicitly enable or disable Extended Arithmetic Mode. Slot 1 and 2
					jumps have no effect upon P9, so its selection is unchanged as these jumps are executed. In the F18A, slot 1 and 2
					jumps additionally force P8 to zero. This means the destination of any slot 1 or 2 jump may never be in I/O space.
					<div>The instruction selected for slot 3 must be one of those shaded in <a href="#5_4">Figure 3 </a>above. When the desired opcode cannot be </div>
					fit into the current instruction word, either because it may not be used in slot 3 or because it is a jump whose
					destination requires a longer address field, the remaining slots of the current word may be filled with nop instructions.
					In addition to jumps, three other instructions affect the consecutive execution of opcodes within an instruction word:
					; (return) and ex (execute) discontinue execution of the current instruction word.
					unext (micronext) conditionally causes execution to loop back to slot 0 (and continue with consecutive slots).
					When the loop is complete, execution continues with the slot following unext .
					The arrayForth compiler formats instruction words correctly and automatically. If you wish to compile your own
					<div>instruction words, to modify code in memory, or to write your own compiler for the F18A, please refer to section <a href="#9_4">2.4.4 </a></div>
					for details about instruction encoding.
					2.3.2 Stack Operation
					In all cases of pushing and popping stacks mentioned above, the mechanism is the same:
					Pushing data stack: S is pushed onto the circular stack, replacing its bottom entry, and T is copied into S.
					Popping data stack: The top entry of the circular stack is copied into S, and S is copied into T unless the instruction
					states that it sets T to some other value.
					Pushing return stack: R is pushed onto the circular stack, replacing its bottom entry.
					Popping return stack: The top entry of the circular stack is copied into R.
					Pushing and popping of the circular stacks is accomplished by adjusting pointers. When popping a circular stack, the
					previous top item becomes the new bottom item. When pushing onto a circular stack, the new top value replaces the
					previous bottom value.
					The F18 Computer
					6
					<a name="6_0"> </a>
					<a name="6_1"> </a>
					<a name="6_2"> </a>
				</div>
			</div>
		</div>
		<div id="page_6">
			<div>
				<div>
					2.3.3 Arithmetic, Logic and Register Manipulation
					<div>There are sixteen instructions in this class. Approximate execution times (see section <a href="#9_1">2.4.1) </a>are 1.5 nanoseconds. </div>
					Op
					Source
					Function
					x10
					+*
					Multiply step.
					Signed Multiplicand is in S, unsigned multiplier in A, T=0 at start of a step sequence.
					Uses T:A as a 36-bit shift register with multiplier in A. Does the following:
					1. If bit A0 is zero, shifts the 36-bit register T:A right one bit arithmetically (T17 is not
					changed and is copied into T16. T0 is copied to A17 and A0 is discarded.)
					2. If bit A0 is one, S and T are added as though they had both been extended to be
					19 bit signed numbers, and the 37-bit concatenation of this sum and A is shifted
					right one bit to replace T:A. Overflow may occur if S and T are both nonzero and
					their signs differ; this can only occur through improper initialization of T.
					This instruction is affected in Extended Arithmetic Mode by including the latched carry in
					the sum in case (2) above, and by latching the carry out from bit 17 of the sum, but
					this is not a particularly useful effect and may be changed in later F18 versions.
					You must arrange that the previously executed instruction has not changed the values of
					S, T or P9. Use nop preceding Multiply Step if necessary to meet this condition.
					Two-Star. Shifts T left one bit logically (shifts zero into T0, discards T17) thus multiplying a
					signed or unsigned value by two.
					Two-Slash. Shifts T right one bit arithmetically (propagates T17 by leaving it unchanged;
					discards T0) thus dividing a signed value by two and discarding the positive remainder.
					Not. Inverts each bit of T, replacing T with its ones complement.
					Plus. Replaces T with the twos complement sum of S and T. Pops data stack into S.
					This instruction is affected in Extended Arithmetic Mode, becoming Add with carry.
					Includes the latched carry in the sum, and latches the carry out from bit 17.
					You must arrange that the previously executed instruction has not changed the values of
					S, T or P9. Use nop preceding Plus if necessary to meet this condition.
					Replaces T with the Boolean AND of S and T. Pops data stack.
					x11
					x12
					2*
					2/
					x13
					x14
					—
					+
					x15
					x16
					x17
					x18
					x19
					x1A
					and
					or
					drop
					dup
					pop
					over
					Exclusive Or. Replaces T with the Boolean XOR of S and T. Pops data stack.
					Drops the top item from the data stack by copying S into T and popping the data stack.
					Duplicates the top item on the data stack by pushing the data stack and copying T into S.
					Moves R into T, popping the return stack and pushing the data stack.
					Makes a copy of S on top of the data stack by pushing S onto the stack, moving T into S, and
					replacing T by the previous value of S.
					x1B
					x1C
					x1D
					x1E
					x1F
					a
					.
					Fetches the contents of register A into T, pushing the data stack.
					Nop. Spends time while making no explicit state changes in registers or stacks.
					Moves T into R, pushing the return stack and popping the data stack.
					B-Store. Stores T into register B, popping the data stack.
					push
					b!
					a!
					A-Store. Stores T into register A, popping the data stack.
					Depending on their arguments, any of these may alter T and/or S, with the sole exception of nop .
					The carry latch is not affected by reset and its state on power-up is unpredictable.
					The F18A Computer
					7
					<a name="7_0"> </a>
				</div>
			</div>
		</div>
		<div id="page_7">
			<div>
				<div>
					2.3.4 Memory Read and Write
					<div>There are eight instructions in this class. Approximate execution times (see section <a href="#9_1">2.4.1) </a>are 5.1 nanoseconds when </div>
					reading or writing internal memory. The addresses used may be in memory or I/O spaces; some I/O addresses may
					suspend execution until the conditions necessary for their completion are met. The notation [X] should be read in the
					descriptions below as “the memory or I/O addressed by X”.
					Op
					Source
					@p
					@+
					@b
					@
					!p
					!+
					!b
					!
					Function
					x08
					x09
					x0A
					x0B
					x0C
					x0D
					x0E
					x0F
					<div>Fetch-P. Pushes data stack, reads [P] into T, and increments P (see <a href="#5_1">2.2) </a></div>
					<div>Fetch-plus. Pushes data stack, reads [A] into T, and increments A (see <a href="#5_1">2.2) </a></div>
					Fetch-B. Pushes data stack and reads [B] into T.
					Fetch. Pushes data stack and reads [A] into T.
					<div>Store-P. Writes T into [P], pops the data stack, and increments P (see <a href="#5_1">2.2) </a></div>
					<div>Store-plus. Writes T into [A], pops the data stack, and increments A (see <a href="#5_1">2.2) </a></div>
					Store-B. Writes T into [B] and pops the data stack.
					Store. Writes T into [A] and pops the data stack.
					Figure 6 Memory Read and Write Instructions
					2.3.5 Transfer of Program Control
					<div>There are eight instructions in this class. Approximate execution times (see section <a href="#9_1">2.4.1) </a>are 5.1 nanoseconds when </div>
					the destination is in internal memory. unext takes approximately 2.0 nanoseconds. When P is changed by one of
					these instructions, the new destination may be in memory or I/O space. Some I/O addresses may suspend execution
					until the conditions necessary for their completion are met.
					Op
					Source
					Function
					x00
					;
					Return. Moves R into P, popping the return stack. Skips any remaining slots and fetches next
					instruction word.
					x01
					x02
					x03
					ex
					Execute. Exchanges R and P, skips any remaining slots and fetches next instruction word.
					<div>name ; Jump. Sets P to destination address (see <a href="#6_0">2.3.1) a</a>nd fetches next instruction word. </div>
					name
					Call. Moves P into R, pushing an item onto the return stack, sets P to destination address
					<div>(see <a href="#6_0">2.3.1) a</a>nd fetches next instruction word. </div>
					x04
					unext
					Micronext. If R is zero, pops the return stack and continues with the next opcode. If R is
					nonzero, decrements R by 1 and causes execution to continue with slot 0 of the current
					instruction word without re-fetching the word.
					x05
					x06
					x07
					next
					if
					Next. If R is zero, pops the return stack and continues with the next instruction word
					<div>addressed by P. If R is nonzero, decrements R by 1 and jumps (see <a href="#6_0">2.3.1). </a></div>
					If. If T is nonzero, continues with the next instruction word addressed by P. If T is zero,
					<div>jumps (see <a href="#6_0">2.3.1). </a></div>
					Minus-if. If T is negative (T17 set), continues with the next instruction word addressed by P.
					<div>If T is positive, jumps (see <a href="#6_0">2.3.1). </a></div>
					-if
					Figure 7 Control Transfer Instructions
					The F18 Computer
					8
					<a name="8_0"> </a>
					<a name="8_1"> </a>
				</div>
			</div>
		</div>
		<div id="page_8">
			<div>
				<div>
					2.4 Fine Points
					For full mastery of the F18A computer, there are several additional things you should understand.
					2.4.1 Execution Time
					The F18A is built from asynchronous logic, therefore its instruction times are naturally approximate. The time required
					for all activity varies directly with temperature, inversely with power supply voltage (VDD), and randomly within a
					statistical distribution due to variations in the process of fabricating the chips themselves. Additional variations may
					occur with minor revisions in the version of F18 technology used by a particular chip. Applications should not be
					designed to depend upon the speed of activities within F18 computers for timing purposes without taking all of these
					variables into consideration.
					The time required for interaction with entities outside an F18 computer (other nodes, or I/O) naturally depends on the
					behavior of those outside devices.
					The approximate execution times shown in the text above are typical of the F18A. For any particular chip, see its
					Product Briefs and Data Books for pertinent preliminary information from prototype chips and, later, statistical data
					from measurements on production chips.
					2.4.2 Prefetch considerations
					Any F18A computer may, when it is logically possible to do so, be designed to fetch instructions before they are
					needed. We reserve the right to make changes or improvements in this process with each chip we design, and
					therefore you are advised, in the interest of software portability, not to depend on any particular prefetching strategy
					for the timing of your program or for avoiding the need to insert a nop between an instruction that alters S, T or P9 and
					an add or multiply step instruction. If your requirements justify sacrificing upward compatibility in favor of taking such
					steps to achieve maximum performance, contact our support staff (hotline mailbox) for recommendations pertinent to
					specific chips.
					2.4.3 Best Practices
					Within I/O space, read and write only those addresses defined to be readable or writable to avoid unexpected results.
					Reading or writing inappropriate I/O addresses, or writing ROM, may result in a hung computer.
					Upward compatibility to future versions of the F18 is not guaranteed. Think in terms of source, not binary
					compatibility. Be aware of the reset state of the io register since that will be the default setting for any bits assigned
					to control future I/O facilities.
					2.4.4 Compiling Instructions Yourself
					If you are writing a compiler, or wish to compose F18A instructions by hand or to read or modify instruction words in
					memory, you must be aware that instruction words are encoded as follows:
					<div>Compose instruction words as shown in <a href="#6_0">2.3.1 </a>with opcode values as shown in the “Op” columns of the instruction </div>
					tables above and exclusive OR the result with the value x15555. If the word requires a destination address field, mask
					<div>that field to zero and insert an un-encoded address value consistent with those shown in <a href="#5_1">2.2 </a>and the specific I/O </div>
					<div>addresses defined in section <a href="#10_0">3. </a>In the particular case of slot zero jumps, it is permissible to set unused bits 10, 11 and </div>
					12 to any convenient states.
					The F18A Computer
					9
					<a name="9_0"> </a>
					<a name="9_1"> </a>
					<a name="9_2"> </a>
					<a name="9_3"> </a>
					<a name="9_4"> </a>
				</div>
			</div>
		</div>
		<div id="page_9">
			<div>
				<div>
					3. F18A I/O Facilities
					Input-output capabilities of F18A nodes consist of internode communication ports (2, 3, 4, or 5 depending on array
					configuration and the node’s position in the array) and, for nodes on array edges, optional GPIO pins and/or other
					more specialized circuitry such as parallel buses, analog I/O, or serializer-deserializer (SERDES).
					<div><a href="#10_2">Figure 8 </a>shows all of the defined I/O addresses </div>
					Name
					io
					Addr
					x15D
					Description
					Notes
					in the F18A. Shaded addresses are not present
					in all nodes; see the numbered notes for more
					information.
					I/O control and status (see
					below). Bit assignments depend
					on the facilities present.
					Up port with no handshake.
					Up
					Left port with no handshake.
					Left
					data
					---u
					ldata
					--l-
					--lu
					-d--
					-d-u
					-dl-
					-dlu
					r---
					r--u
					r-l-
					r-lu
					rd--
					rd-u
					rdl-
					rdlu
					Addresses should only be used in a given node
					if they are present according to these notes;
					right, down, left and up ports are present for
					read and write in all nodes except as noted:
					x141
					x145
					x171
					x175
					x165
					x115
					x105
					x135
					x125
					x1D5
					x1C5
					x1F5
					x1E5
					x195
					x185
					x1B5
					x1A5
					3
					1
					3
					2
					Left or Up
					Down
					1,2
					Blank: Present for read/write in all nodes.
					1
					Absent on top and bottom nodes
					unless supported by particular I/O
					circuitry
					Down or Up
					Down or Left
					Down, Left or Up
					Right
					Right or Up
					Right or Left
					Right, Left or Up
					Right or Down
					Right, Down or Up
					Right, Down or Left
					Right, Down, Left or Up
					1
					2
					1,2
					2
					3
					Absent on side nodes unless
					supported by particular I/O circuitry
					1
					2
					1,2
					Present only when documented as
					such for specific I/O circuitry; read,
					write, and handshaking facilities are
					defined by each class of circuitry.
					1
					2
					1,2
					Figure 8 I/O Address Table
					3.1 The io Register
					This 18-bit control and status register is each F18A computer’s interface with its I/O circuitry, if any, and with
					handshake lines for any communication ports that are present. The bit assignments are shown for reference here.
					Their semantics are defined in detail in later sections. By default, io is populated with latches that read as the inverse
					of what was last written to them. Any io bits that are undefined for a given node because the associated I/O facilities
					are absent implement this behavior. A second general principle is that on reset each node’s io register is set as though
					the value x15555 had been written to it under program control.
					Bit
					reset
					17 16
					15
					0
					14
					1
					13
					0
					12
					1
					11
					0
					10
					1
					9
					8
					1
					7
					6
					1
					5
					0
					4
					1
					3
					0
					2
					1
					1
					0
					0
					1
					0
					1
					0
					phan
					9
					0
					phan
					7
					GPIO pin
					17 control
					SR
					GPIO pin
					5 control
					GPIO pin
					3 control 1 control
					GPIO pin
					WD
					WRITE
					Alt write
					READ
					A/D mode DB
					Lr-
					9-bit D/A value XORed with x155
					pin
					17
					pin
					5
					pin
					3
					pin
					1
					Rr- Rw Dr- Dw
					Lw Ur- Uw
					Figure 9 IO Register Bit Assignments
					The F18 Computer
					10
					<a name="10_0"> </a>
					<a name="10_1"> </a>
					<a name="10_2"> </a>
					<a name="10_3"> </a>
				</div>
			</div>
		</div>
		<div id="page_10">
			<div>
				<div>
					3.2 Suspension
					A node is either executing instructions at full speed or it is suspended in mid-instruction, waiting for a “wake up”
					condition that depends on the state of another node or of other I/O circuitry. Since an F18 has no clock, the acts of
					suspending and waking up consume no energy or time in and of themselves. Perception of changing conditions takes
					picoseconds within the chip and, typically, nanoseconds for events external to the chip. When a node is suspended the
					power used by its computer is nil, on the order of 100 nanowatts. When executing, an F18 computer uses power on
					the order of less than 6 milliwatts depending on the instructions used and the data on which they are operating.
					3.3 Communication Ports
					Communication (comm) ports provide for direct, point to point bidirectional information transfer within a chip. Each
					F18A node may have from two to five ports connected. Comm ports are named Right, Down, Left, Up; the fifth port is
					not implemented in F18A based chips.
					Each comm port is an independent, bidirectional, half duplex 18-bit channel connecting two nodes. Communication
					occurs when a sending node writes to a comm port address and a receiving node to which that port is connected reads
					the corresponding comm port address at the same time. When a node operates on a port the data transfer occurs at
					approximately memory speed unless the other node connected to the port is not yet performing the complementary
					operation; in this case the operating node suspends, waking up when the other node connected to that port is
					performing the complementary operation.
					The status of each port is visible through the bits in io labeled R/D/L/Ur- and R/D/L/Uw above. Dr- is zero if the node
					at the other end of Down is reading; Lw is one if the node at the other end of Left is writing.
					3.3.1 Multiport Operations
					<div>As shown in <a href="#10_2">Figure 8 </a>above, the I/O addressing scheme of the F18A permits comm ports to be combined. Reading or </div>
					writing Multiport Addresses such as rd-u is permitted and suspends until one or more of the nodes to which the
					selected ports connect is performing the complementary operation. The design rules for communication flow using
					multiport operations are straightforward: When a node is doing a multiport read, only one of the selected ports may
					be written by another node at any given time. When a node is doing a multiport write, every node that intends to read
					the value written must already be doing so and suspended. It is not possible to directly determine which port(s)
					transferred data after a multiport operation by inspection of io; if it is necessary for a node to make this determination
					it must be accomplished via protocols.
					3.3.2 Port Execution
					An F18 may execute instruction streams directly from a comm port. When the F18 fetches an instruction word from a
					comm port, P is not incremented and unless the instruction stream transfers control elsewhere subsequent words are
					fetched from the same port. @p reads a word from the port and !p writes a word into the port. Multiport addresses
					may be used so long as the design rules in the preceding section are followed.
					F18A I/O Facilities
					11
					<a name="11_0"> </a>
					<a name="11_1"> </a>
					<a name="11_2"> </a>
					<a name="11_3"> </a>
				</div>
			</div>
		</div>
		<div id="page_11">
			<div>
				<div>
					3.4 Nodes with GPIO Pins
					<div>Any edge node may have up to four fully featured General Purpose I/O (GPIO) pins. A schematic is shown in <a href="#12_4">Figure 10. </a></div>
					These pins have useful electrical characteristics and are designed to facilitate software defined I/O. GPIO pins are
					<div>designated by their bit positions as shown in <a href="#10_3">Figure 9 </a>above (pins 17, 5, 3 and 1.) </div>
					Under program control, you may place each pin in one of four states
					by writing a value into its 2-bit GPIO field of io as follows:
					Vdd
					Value State of pin drive circuitry
					Drive hi (11)
					00
					01
					High Impedance (≈2.8 pF, ≈250 MΩ)
					Weak pulldown (≈38 µA in saturation). This is the reset
					state of all GPIO pins.
					GPIO
					pad
					Input
					10
					11
					Drive to VSS (≈41 mA in saturation)
					Drive to VDD (≈41 mA in saturation)
					Drive low (10)
					Weak PD (01)
					Vss
					Regardless of the drive state selected for a GPIO pin, you may
					always read the io register to measure the actual voltage on the pin
					as a logic state (1=pin voltage high) using bits 17, 5, 3 or 1
					Figure 10 F18A GPIO Pin Circuit
					Input hysteresis, provided by two Schmitt triggers, protects against noise and other classical problems with signals
					whose rise and fall times are long relative to computer speeds. The F18A computers and I/O circuitry are fast and
					sensitive enough that parasitic resistance, inductance and capacitance effects may be directly observed by reading the
					pins as external circuits are being driven, and are fast enough that a 1 MHz sine wave is a slow-moving signal. Refer to
					the documentation on specific chips for electrical characteristics of their GPIO pins.
					3.4.1 Wakeup Pins
					When an edge node is configured with a GPIO pin 17 it may be configured and documented for wakeup on that pin.
					When this is the case, the pin may be “read” using a comm port address which becomes present for reading: Up for
					nodes on the top and bottom edges of the array, or Left for nodes on the lateral sides. The node suspends until the pin
					is in the state specified by the WD bit in the io register. When WD is written as zero, which is the reset state of that bit,
					a pin read suspends until the pin is logically high. To suspend until the pin is low, write 1 to WD. When the read
					completes, it is required that you must immediately drop the value that was read into T.
					F18A multiport read operations may include the wakeup pin as Up or Left. In this case you must still immediately drop
					the value read. To deduce that the pin was the source of the wakeup it is necessary to read io and check the current
					state of bit 17.
					3.4.2 Shared (Read-only) Pins
					Some nodes may be configured to observe the voltage on a GPIO pin that they do not directly control. This is typically
					done to provide versatility in timing analog to digital conversion. In these cases, the shared pin may be read as bit 17
					of io. Wakeup may be enabled for reading, writing, or both on a shared pin, as will be documented for the type of I/O
					node observing the pin. Wakeup polarity is controlled by WD as with GPIO pins. See the chip Data Book for details on
					each node's wakeup configuration as the choice of this configuration may depend on their intended uses.
					3.4.3 Phantom Wakeup Signals
					A sending node may be configured to drive a “phantom” signal that a receiving node treats as a shared pin. In this
					<div>configuration the receiving node operates exactly as described above in <a href="#12_2">3.4.2. </a>The sending node controls the phantom </div>
					signal by writing into bits phan 7 or phan 9; writing 1 makes the signal look high to the receiver, 0 makes it look low,
					and the reset state of io is equivalent to writing zeroes (low) into these bits.
					The F18 Computer
					12
					<a name="12_0"> </a>
					<a name="12_1"> </a>
					<a name="12_2"> </a>
					<a name="12_3"> </a>
					<a name="12_4"> </a>
				</div>
			</div>
		</div>
		<div id="page_12">
			<div>
				<div>
					3.5 Parallel Bus Support
					F18A Parallel Bus support consists of a cluster of three adjacent nodes, typically laid out on the “bottom” edge of a
					chip. The center node has 4 GPIO pins for control signals and each of its parallel port neighbors has I/O circuitry for an
					18-bit bidirectional bus interface. The purposes of all these pins and the direction and timing of signals are defined by
					software.
					The center node is configured to act as sender of a phantom wakeup signal to each of the parallel bus nodes to
					supplement the comm ports between them to provide versatility in timing.
					In each node with an 18-bit bus, the addresses Up and Data are enabled for reading and writing. The difference
					<div>between these two addresses is that operations on Up suspend when appropriate (see <a href="#12_3">3.4.3) w</a>hile operations on Data </div>
					do not depend upon the phantom wakeup signal.
					Each of the 18 pins of a parallel port node has a subset of the capabilities of a GPIO pin. When DB in io is set to 1 (its
					reset state) all 18 pins are in output mode and are driven high or low depending on the state of an 18-bit Bus Register.
					When DB is set to zero, all 18 pins are set to high impedance input mode. Unlike GPIO pins, parallel bus pins do not
					have Schmitt triggers, nor do they have weak pull-down capabilities.
					Writing to Up or Data always sets the Bus Register, regardless of the state of DB. Writing a 1 or 0 to a bit in this
					register will, in output mode, drive the corresponding pin to VDD or VSS, respectively. Reading from Up or Data in input
					mode reads the pin states with high reading as 1; in output mode, reading returns the current value of the Bus
					Register.
					Note that parallel buses reset to output mode and that reset does not initialize the Bus Register. Its value after power
					up is unpredictable.
					Refer to the documentation on specific chips for electrical characteristics of their parallel bus pins.
					3.6 SERDES Nodes
					The high speed Serializer-Deserializer (SERDES) node is equipped with a transceiver for 2-wire (clock and data)
					synchronous, half duplex communications at a rate of approximately 450 megabits per second. While a SERDES node
					might be capable of communicating with something other than another SERDES node, it was not designed with any
					other objective than communication between our chips.
					To receive an 18-bit word, a SERDES node must place the value x3FFFE in T and read the Up port. The node suspends
					until a word has been received.
					To begin transmitting, a SERDES node must write the first word to Data and must then set bit 17 of io to 1. Each
					subsequent word is written to Up ; the node will suspend until the preceding word has been finished and transmission
					of the new word may begin. If the node wishes to stop transmitting cleanly, it must wait long enough after writing the
					last word to Up (or after setting io bit 17 if only one word is to be transmitted) for a full word to have been sent.
					Refer to the documentation on specific chips for electrical and timing characteristics of their SERDES nodes and pins.
					F18A I/O Facilities
					13
					<a name="13_0"> </a>
					<a name="13_1"> </a>
				</div>
			</div>
		</div>
		<div id="page_13">
			<div>
				<div>
					3.7 Analog Nodes
					Any F18A edge node may be configured with an analog input pin and an analog output pin along with the associated
					<div>circuitry. A block diagram is shown in <a href="#14_1">Figure 11. </a></div>
					Vss
					The Analog to Digital converter (ADC) consists of a high speed,
					free running down-counter whose frequency varies as a
					ADC
					pad
					mux
					function of input voltage between ≈3.6 GHz for VDD input and
					<div>≈5.6 GHz for VSS, as shown in the typical curve in <a href="#14_3">Figure 13. </a></div>
					The A/D Mode field in io controls the counter as follows:
					sel
					io
					Vdd
					run
					Value Mode and input of ADC counter
					vco
					00
					01
					10
					11
					High Impedance ADC input pad (≈2.8 pF, ≈250 MΩ)
					VDD Calibration
					Counter disabled to save power (the reset state)
					VSS Calibration
					counter
					current
					source
					DAC
					pad
					9
					A voltage is measured within the operating range (≈750 mV to
					≈1.3v) by calculating the difference between two readings
					separated by a known time interval.
					<div>R<sub>L </sub></div>
					Figure 11 Analog I/O Circuitry
					For analog nodes on top and bottom edges, Data and Up are present for reading and writing; for those on sides of an
					array, Ldata and Left are present. The procedure for sampling the ADC requires two steps: First write to the Up/Left
					or Data/Ldata port as appropriate to signal the VCO to stop for reading, and then read from Data/Ldata or Up/Left as
					appropriate to obtain the value of the down-counter and restart the VCO. Reading without writing first will not yield
					<div>useful values. An analog node is equipped with a shared wakeup pin (see <a href="#12_2">3.4.2) a</a>nd configured to suspend when </div>
					writing to Up/Left.
					The Digital to Analog Converter (DAC) is a programmable current source designed to produce a voltage across a
					resistance to ground or to source an op-amp. By writing the xor of a desired value and x155 into the low order nine
					bits of io that value controls the DAC output. A value of x1FF (written as x0AA) sets the DAC for maximum current; a
					value of 0 (written as x155, the reset state) sets minimum current, high impedance output. Typical DAC transfer
					<div>functions, in mV versus DAC values, into 75, 50, 37.5 and 8 Ohms are shown in <a href="#14_2">Figure 12; </a>as the resistance decreases, </div>
					the voltage decreases and the function becomes more linear.
					Refer to the documentation on specific chips for electrical characteristics of their analog nodes.
					Figure 13 Typical ADC Transfer Function
					Figure 12 Typical DAC Transfer Function
					The F18 Computer
					14
					<a name="14_0"> </a>
					<a name="14_1"> </a>
					<a name="14_2"> </a>
					<a name="14_3"> </a>
				</div>
			</div>
		</div>
		<div id="page_14">
			<div>
				<div>
					4. Revision History
					REVISION
					DESCRIPTION
					110412
					Initial Release
					Resolve some comments received: Add Ldata for side Analog nodes. Clarify variable length destination
					address field. Emphasize conditions for overflow in multiply step. Clarify shared pin wake-up
					configuration is a chip design issue not an F18 issue.
					171107
					F18A I/O Facilities
					15
					<a name="15_0"> </a>
				</div>
			</div>
		</div>
		<div id="page_15">
			<div>
				<div>
					<div>GreenArrays<sup>® </sup></div>
					Product Data Book DB001 Revised 11/07/17
					IMPORTANT NOTICE
					GreenArrays Incorporated (GAI) reserves the right to make corrections, modifications, enhancements, improvements, and other
					changes to its products and services at any time and to discontinue any product or service without notice. Customers should
					obtain the latest relevant information before placing orders and should verify that such information is current and complete. All
					products are sold subject to GAI’s terms and conditions of sale supplied at the time of order acknowledgment.
					GAI disclaims any express or implied warranty relating to the sale and/or use of GAI products, including liability or warranties
					relating to fitness for a particular purpose, merchantability, or infringement of any patent, copyright, or other intellectual
					property right.
					GAI assumes no liability for applications assistance or customer product design. Customers are responsible for their products and
					applications using GAI components. To minimize the risks associated with customer products and applications, customers should
					provide adequate design and operating safeguards.
					GAI does not warrant or represent that any license, either express or implied, is granted under any GAI patent right, copyright,
					mask work right, or other GAI intellectual property right relating to any combination, machine, or process in which GAI products
					or services are used. Information published by GAI regarding third-party products or services does not constitute a license from
					GAI to use such products or services or a warranty or endorsement thereof. Use of such information may require a license from a
					third party under the patents or other intellectual property of the third party, or a license from GAI under the patents or other
					intellectual property of GAI.
					Reproduction of GAI information in GAI data books or data sheets is permissible only if reproduction is without alteration and is
					accompanied by all associated warranties, conditions, limitations, and notices. Reproduction of this information with alteration is
					an unfair and deceptive business practice. GAI is not responsible or liable for such altered documentation. Information of third
					parties may be subject to additional restrictions.
					Resale of GAI products or services with statements different from or beyond the parameters stated by GAI for that product or
					service voids all express and any implied warranties for the associated GAI product or service and is an unfair and deceptive
					business practice. GAI is not responsible or liable for any such statements.
					GAI products are not authorized for use in safety-critical applications (such as life support) where a failure of the GAI product
					would reasonably be expected to cause severe personal injury or death, unless officers of the parties have executed an
					agreement specifically governing such use. Buyers represent that they have all necessary expertise in the safety and regulatory
					ramifications of their applications, and acknowledge and agree that they are solely responsible for all legal, regulatory and safety-
					related requirements concerning their products and any use of GAI products in such safety-critical applications, notwithstanding
					any applications-related information or support that may be provided by GAI. Further, Buyers must fully indemnify GAI and its
					representatives against any damages arising out of the use of GAI products in such safety-critical applications.
					GAI products are neither designed nor intended for use in military/aerospace applications or environments unless the GAI
					products are specifically designated by GAI as military-grade or "enhanced plastic." Only products designated by GAI as military-
					grade meet military specifications. Buyers acknowledge and agree that any such use of GAI products which GAI has not
					designated as military-grade is solely at the Buyer's risk, and that they are solely responsible for compliance with all legal and
					regulatory requirements in connection with such use.
					GAI products are neither designed nor intended for use in automotive applications or environments unless the specific GAI
					products are designated by GAI as compliant with ISO/TS 16949 requirements. Buyers acknowledge and agree that, if they use
					any non-designated products in automotive applications, GAI will not be responsible for any failure to meet such requirements.
					The following are trademarks or registered trademarks of GreenArrays, Inc., a Wyoming Corporation: GreenArrays, GreenArray
					<div>Chips, arrayForth, and the GreenArrays logo. polyFORTH is a registered trademark of FORTH, Inc<a href="http://www.forth.com/" target="_blank">. (</a><a href="http://www.forth.com/" target="_blank">www.forth.com</a><a href="http://www.forth.com/" target="_blank">) </a>and is used </div>
					by permission. All other trademarks or registered trademarks are the property of their respective owners.
					<div>For current information on GreenArrays products and application solutions, see <a href="http://www.greenarraychips.com/" target="_blank">www.GreenArrayChips.com </a></div>
					Mailing Address: GreenArrays, Inc., 821 East 17th Street, Cheyenne, Wyoming 82001
					Printed in the United States of America
					Phone (775) 298-4748 fax (775) 548-8547 email Sales@GreenArrayChips.com
					Copyright © 2010-2017, GreenArrays, Incorporated
				</div>
			</div>
		</div>
	</body>
</html>